## Autoloading with Composer

UserFrosting builds on top of a number of existing components.  After all, why reinvent the wheel if there is already a well-documented, well-tested solution?  However, new versions of these *dependencies* are released all the time, and it can be difficult to keep up with changes.

To efficiently manage UserFrosting's dependencies, we use [Composer](https://getcomposer.org/).  Composer is a dependency management tool that you can install locally on your development workstation.  When run from the command line in your project directory, it consults a special schema file, [`composer.json`](userfrosting/composer.json), and downloads the dependencies defined in that file from a central repository called [Packagist](https://packagist.org/).  By default and by convention, each component is placed in a separate subdirectory of the `vendor` directory.  [UserFrosting's `vendor` directory](userfrosting/vendor) is located in the `userfrosting` directory.

Composer also **autoloads** the files and classes from these packages.  This means that instead of having a long list of `require` statements in the config file, we only need to include one file, `vendor/autoload.php`.  This file is automatically generated by Composer by scanning the package contents.  Composer can also autoload the files and classes that are specific to UserFrosting.  When you run `composer update`, Composer will scan the `auth`, `controllers`, and `models` directories for new files and classes.

### Installing Composer

For your convenience, the latest versions of UserFrosting's dependencies are already included in this repository.  However, if you choose to use UserFrosting for your own project, you will likely want to do one or more of these things:

1. Install a package that isn't already included;
2. Update a package to a newer version;
3. Add your own files and class definitions to the core codebase.

In this case, you will need to install Composer.

To install composer on a Mac or other Unix-like operating system, visit [install it](https://getcomposer.org/doc/00-intro.md#installation-linux-unix-osx).  It is recommended that you install it globally.

To add additional dependencies, you will need to modify the `userfrosting/composer.json` file.  After this, run `composer update` in the `userfrosting` subdirectory to install the new dependencies.

All dependencies are installed in `userfrosting/vendor`.  **Do not manually change the contents of this directory!**

Libraries which have been installed with composer are autoloaded, so there is no need to include individual files.  All you need is the `vendor/autoload.php` file, which is already included in `userfrosting/config-userfrosting.php`.  See the "Configuration" section for more information on the config file.

## Front Controllers and the Slim Microframework

If you're coming from a previous version of UserFrosting, you've probably that the flow of the code has changed substantially.  In particular, we now use a [**front controller pattern**](https://en.wikipedia.org/wiki/Front_Controller_pattern), also known as a URL router, which creates a layer of abstraction between the URL that you visit (for example, http://mysite.com/dashboard) and the code that gets run.

If you're new to PHP, you've probably been using the **one-url-one-file** scheme.  This means that, in the document root of the filesystem on your server (for example, `/~alexw/dev/htdocs/`), you create `.php` files that correspond to the URLs that users of your site can visit.  So, you might have a file `/~alexw/dev/htdocs/command-center.php`, and then you visit `http://localhost/command-center.php` to see the output of this script.

But here's the deal: there's no law set in stone that says it *has* to work this way.  When you visit a URL, all you're really doing is placing an HTTP `GET` **request** to a server (e.g., Apache).  The request is basically asking the server to generate the appropriate **response** to that request.  In the case of your typical home setup with Apache and PHP, the default behavior for a request is to look for a PHP script with the same name (`command-center.php`) in some preconfigured document root directory, run it, and send its output back as the response, where it is displayed in the client's browser.

However, it is possible to configure the server to interpret requests differently - this is known as **routing**.  Why would you want to do this?  Because it gives you more flexibility.  Let's say you want your site to have a URL like `http://mysite.com/blog/2015-06-01/1`, which points to the first page of your blog posts from June 1.  Without routing, you'd need to have actual subdirectories on your server's filesystem - `/~alexw/dev/htdocs/blog/2015-06-01/1.php`.

What's wrong with this?  Well, let's say you want the same blog post to also appear at other URLs, for example `http://mysite.com/blog/rants` and `http://mysite.com/blog/favorites/1`.  You'd need to have these subdirectories as well, and you'd have to create actual scripts that output the same content.  This becomes even more problematic if you want dynamically generated URLs, like `http://mysite.com/blog/words-from-a-database`.

On the other hand, with a front controller, you can link URLs to specific pieces of code without needing to create a separate file.

### How does UserFrosting make this happen?

UserFrosting uses the [Slim Framework](http://www.slimframework.com/) to make this work.  Here's how:

1.  When a user visits a URL such as `http://mysite.com/users/u/1`, they are actually seeing a [rewritten URL](https://en.wikipedia.org/wiki/Rewrite_engine).  In reality, every request is sent to `index.php`, with `users/u/1` sent as a request parameter.  In Apache, this is done with an `.htaccess` file (a preconfigured `.htaccess` file is included with UserFrosting).  Other web server technologies may use a different type of configuration file.
2. In `index.php`, a number of routes are defined, which tell it how to respond based on the request parameter.  Slim provides the framework for handling these routes.  For example:

```
$app->get('/users/u/1/?', function () use ($app) {
    echo "Hello I am user number 1";
});
```

generates the output for `http://mysite.com/users/u/1`.  `$app` is the Slim application (a global variable), and `get` tells us that we are dealing with a `GET` request (any time you navigate to a URL in your browser, you are submitting a `GET` request).

Another advantage is that routes can have variables in them.  For example:

```
$app->get('/users/u/:user_id/?', function ($user_id) use ($app) {
    echo "Hello I am user number $user_id";
});
```

Now we can visit any URL, for example `http://mysite.com/users/u/27`, and we will get the corresponding output "Hello I am user number 27."

## Code Structure and MVC

The code for UserFrosting is divided into two main folders - `public` and `userfrosting`.  `public` is the directory that faces the world; any file that a visitor to your site can directly access is in this directory.  Everything else is in `userfrosting`.

```
/                 
|-- public          // This directory should be publicly accessible (usually permissions set to 750 or 755)
|   |
|   |-- css
|   |-- images
|   |-- js
|   |-- .htaccess
|   |-- index.php
|
|-- userfrosting    // This directory should only be accessible by the server (usually set permissions to 700)
|   |-- auth
|   |-- controllers
|   |-- locale
|   |-- models
|   |-- plugins
|   |-- schema
|   |-- templates
|   |-- vendor
|   |-- composer.json
|   |-- composer.lock
|   |-- config-userfrosting.php
```             
                
If you're new to URL routing and the front controller pattern, you may be wondering - how can everything be accessible from `public` when I only see one`.php` file in there?

**Don't panic -** this is how it's supposed to work.  The content and behavior of each page are no longer locked up into individual `.php` files.  Instead, all URLs are redirected to `index.php` (via the `.htaccess` file if you're using Apache).  `index.php` then calls the appropriate **controller**, which generates the appropriate content for the requested page.

For example, here is the **router code** in `index.php` that handles the user management page (`http://yoursite.com/users`):

```
$app->get('/users/?', function () use ($app) {
    $controller = new UF\UserController($app);
    return $controller->pageUsers();
});
```

`$app` is the global [Slim](#slim) object.  The `get` method defines a **route**, which is a URL that your website can accept and generate a response to.  Any time you type a URL into your browser, you are submitting a `GET` request to the web server.

The line

`$controller = new UF\UserController($app);`

tells us to create a new `UserController` object, which is responsible for mediating the interaction between what the client sees (the **view**) and the data and methods that constitute the user accounts (the **model**).

All controller classes for UserFrosting are located in `userfrosting/controllers/`. 

Think of `index.php` as a receptionist at a big company.  The various pages that your site's visitors navigate to are the employees.  When a client wants to visit an employee, they don't go straight to their office - instead, they see the receptionist, tell him where they want to go, get checked in, and then get passed along to a security escort.  The security escort controls their interaction with the members and resources of the company.

`UserController::pageUsers()` is the method responsible for mediating this particular interaction, namely, the rendering of a table of users as HTML.  By convention, any controller method that generates a complete HTML document is prefixed with `page`.

Now, let's look at the code for the `pageUsers` function, which is in `userfrosting/controllers/UserController.php`:

```
public function pageUsers($primary_group_name = null){
   // Optional filtering by primary group
   if ($primary_group_name){
       $primary_group = GroupLoader::fetch($primary_group_name, 'name');
       
       if (!$primary_group)
           $this->_app->notFound();
       
       // Access-controlled page
       if (!$this->_app->user->checkAccess('uri_group_users', ['primary_group_id' => $primary_group->id])){
           $this->_app->notFound();
       }
   
       $users = UserLoader::fetchAll($primary_group->id, 'primary_group_id');
       $name = $primary_group->name;
       $icon = $primary_group->icon;

   } else {
       // Access-controlled page
       if (!$this->_app->user->checkAccess('uri_users')){
           $this->_app->notFound();
       }
       
       $users = UserLoader::fetchAll();
       $name = "Users";
       $icon = "fa fa-users";
   }
   
   $this->_app->render('users.html', [
       'page' => [
           'author' =>         $this->_app->site->author,
           'title' =>          $name,
           'description' =>    "A listing of the users for your site.  Provides management tools including the ability to edit user details, manually activate users, enable/disable users, and more.",
           'alerts' =>         $this->_app->alerts->getAndClearMessages()
       ],
       "box_title" => $name,
       "icon" => $icon,
       "users" => $users
   ]);          
}
```

This controller method can actually accept two kinds of requests: a request to show a table of *all* users, or a request to show a table of users from a single primary group.  To keep it simple for now, let's just look at the part after the `else` statement, which loads the table for all users:

```
// Access-controlled page
if (!$this->_app->user->checkAccess('uri_users')){
    $this->_app->notFound();
}
  
$users = UserLoader::fetchAll();
$name = "Users";
$icon = "fa fa-users";
```

First, we check to make sure that the current user has permission to access this content.  `$this->_app->user` references the currently logged-in user, and `checkAccess` consults the database to determine whether the user has permission to access a certain resource.  Resources are indicated by **authorization hooks** - in this case, `uri_users`.  The database contains a set of authorization rules, which map authorization hooks to users and groups.

Next, we load the collection of all users, using the `UserLoader` class (actually, this is an alias for the `MySqlUserLoader` class in `userfrosting/models/mysql/`, but more about that later).  The `fetchAll` method returns an array of `User` objects.  We then set some other parameters for the page we're about to render, and then pass everything into the `$this->_app->render` method as an array:

```
$this->_app->render('users.html', [
  'page' => [
      'author' =>         $this->_app->site->author,
      'title' =>          $name,
      'description' =>    "A listing of the users for your site.  Provides management tools including the ability to edit user details, manually activate users, enable/disable users, and more.",
      'alerts' =>         $this->_app->alerts->getAndClearMessages()
  ],
  "box_title" => $name,
  "icon" => $icon,
  "users" => $users
]); 
```

The template file for this page, `users.html`, is an HTML file with Twig placeholders and tags.  [Twig](http://twig.sensiolabs.org/) is a templating engine that helps us to better separate the logic (which is the controller's responsibility) from the presentation (which is encapsulated by the Twig template).  This particular template file can be found in `userfrosting/templates/themes/default/`.

You'll notice that in addition to `box_title`, `icon`, and `users`, we pass in some page-level parameters: `author`, `title`, `description`, and `alerts`.  `$this->_app->alerts` is UserFrosting's **message stream**, which contains any error and success messages generated from the last request.  `getAndClearMessages` fetches all of the messages in the stream, and then clears the stream so that the messages won't be shown again on the next page load.

At this point, everything is handed off to Twig, which generates the actual HTML that is sent back to the user.  You can read more about this in [creating content with Twig](#twig). Congratulations!  You've now seen the sequence of steps whereby UserFrosting generates the appropriate content for a particular `GET` request.

## Creating Content with Twig

### Template Files and Dynamic Content

If you're unfamiliar with the MVC paradigm, you may be used to seeing PHP code that looks like this:

```

echo "<table><tr><th>Username</th><th>Email</th></tr>";

$stmt = $db->prepare("SELECT * FROM users);
$stmt->execute($sqlVars);

while ($r = $stmt->fetch(PDO::FETCH_ASSOC)) {
	echo "<tr><td>$r['user_name']</td><td>$r['email']</td></tr>";
}

echo "</table>";

```

We have the code that loads user data from the database all mixed into the code that actually displays the page.  This is commonly referred to as "spaghetti code" - the code twists and turns without any perceivable stucture.  This works for smaller projects, but can create a maintainability nightmare as your project grows.

The solution?  MVC.

The fundamental principle behind MVC (model-view-controller) architecture is **separation of concerns**.  The idea is to have one layer of code (the **model**) responsible for your data model (interacting with the database, performing various manipulations, etc), and another layer (the **view**) for generating the content that clients use to interact with your application.

The **controller** basically does everything else, mediating the interactions between the model and the view.

So, how do we implement this separation?  Well for the view, we use a system of **templates**.  Templates basically look like traditional static HTML documents, but they contain **placeholders** and **tags** that allow the controller to inject dynamic content.  Our templating engine, [Twig](http://twig.sensiolabs.org/), takes the data provided by the controller and uses it to render a specified template.  This is done via the `$this->_app->render` method.

UserFrosting stores all template files in `userfrosting/templates`.  So, any time you want to change the content of your website, this is where you need to look.  You will see two directories:

```
/                 
|-- templates
|   |
|   |-- common
|   |-- themes
```

The templates in `common` are used for generating unthemed content, which consists mainly of the pages that guest users can see.  You will see `.html` files that correspond to the various guest pages: `login`, `register`, etc.  You will also see a `components` subdirectory, which contains common blocks that are included in template files via Twig's  `include` tag.

The `mail` directory contains templates for emails that are automatically sent to your users, such as activation and password reset links.

The `themes` directory, on the other hand, contains **themable** content, which can vary depending on who is logged in.  UserFrosting ships with three default themes: `default`, `nyx`, and `root`.  These themes (and any new ones you create) can be associated with primary groups, and users will be assigned the theme for their primary group when they log in.

So for example, if you assign the theme `nyx` to the group `Hydralisks`, then any user whose primary group is `Hydralisks` will load the `nyx` theme when they log in.  The exceptions are for the root user, who is always given the `root` theme, and guest users, who always get the `default` theme.

When UserFrosting wants to render a particular template, it first looks for the template file in the user's assigned theme.  If it can't find the file there, it then looks in the `default` theme.

This means that if you want some content to be available to all users, you should put your template into the `default` theme.  You can then customize it for different themes by overriding the file in other theme directories.

Every theme also has a theme stylesheet, located in `<theme-directory>/css/theme.css`.  This stylesheet will be automatically loaded for every page.

### Theming


### Menu Items and Authorization Hooks



In v0.3.0, the easiest way to do this would be to override the menu item in the `root` theme.  You can first add the menu item to the `default` theme in [`sidebar.html`](https://github.com/alexweissman/UserFrosting/blob/dev-0.3.0/userfrosting/templates/themes/default/menus/sidebar.html#L18) like so:

```
        {% if checkAccess('uri_zerg') %}
        <li>
            <a href="{{site.uri.public}}/zerg"><i class="sc sc-zerg fa fa-fw"></i> Zerg</a>
        </li>
        {% endif %}
```

And give access to primary group 1 only by setting the following entry in the `authorize_groups` table:

| id  | group_id | hook | conditions |
| ------------- | ------------- | ------------- | ------------- |
| x | 1 | uri_zerg | equals_num(self.primary_group_id,1) |

This basically says "anyone who is a member of group 1 has access to `uri_zerg` as long as their `primary_group_id` equals 1".

If you just want anyone who is a member of group 1 (not just primary) to be able to access the URL, change the condition to `always()`.

To make it disappear from the `root` theme, you could copy the `sidebar.html` template file from the `default` theme to the same subdirectory in the `root` theme.  Then just remove the link from the copy of the file that's in the `root` theme.  All themes are stored in `userfrosting/templates/themes`.
